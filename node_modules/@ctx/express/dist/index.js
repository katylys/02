"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var context = require("@ctx/context");
/**
 * closeNotify returns a middleware that cancels the request's context when
 * the client closes the http connection.
 *
 * ```javascript
 * const app = express()
 *
 * app.use(expressCtx.closeNotify())
 * app.get('/', (req, res) => {
 *   req.ctx.Done().then(() => {
 *     if (ctx.Err() === context.Canceled) {
 *       console.log('user hung up')
 *     }
 *   })
 * })
 * ```
 */
function closeNotify() {
    return function (req, res, next) {
        if (!req.ctx) {
            req.ctx = context.Background();
        }
        var cancel;
        _a = context.WithCancel(req.ctx), req.ctx = _a[0], cancel = _a[1];
        res.on('finish', function () { return cancel(); });
        res.on('close', function () { return cancel(); });
        next();
        var _a;
    };
}
exports.closeNotify = closeNotify;
/**
 * readHeaders returns a middleware that converts headers on incoming requests
 * to values on the request's context object.
 *
 * ```javascript
 * const app = express()
 *
 * app.use(expressCtx.readHeaders(['x-user-id']))
 * app.get('/', (req, res) => {
 *   const xuid = req.ctx.Value('x-user-id')
 *   // Will be undefined if x-user-id was not passed, otherwise the value of
 *   //  x-user-id
 *   console.log(xuid)
 * })
 * ```
 *
 * @param headerNames - The names of the headers to map to context values
 */
function readHeaders(headerNames) {
    return function (req, res, next) {
        if (!req.ctx) {
            req.ctx = context.Background();
        }
        headerNames.forEach(function (headerName) {
            var headerValue = req.header(headerName);
            if (!headerValue) {
                return;
            }
            var cancel;
            _a = context.WithValue(req.ctx, headerName, headerValue), req.ctx = _a[0], cancel = _a[1];
            res.on('finish', function () { return cancel(); });
            var _a;
        });
        next();
    };
}
exports.readHeaders = readHeaders;
/**
 * timeout returns a middleware that attaches a context to the request that
 * will be cancelled after the duration specified in timeoutMilliseconds.
 *
 * ```javascript
 * const app = express()
 *
 * app.use(expressCtx.timeout(1000))
 * app.get('/', (req, res) => {
 *   req.ctx.Done().then(() => {
 *     req.end('timed out')
 *   })
 * })
 * ```
 *
 * @param timeoutMilliseconds The number of milliseconds before the context
 * will be cancelled
 */
function timeout(timeoutMilliseconds) {
    return function (req, res, next) {
        if (!req.ctx) {
            req.ctx = context.Background();
        }
        var cancel;
        _a = context.WithTimeout(req.ctx, timeoutMilliseconds), req.ctx = _a[0], cancel = _a[1];
        res.on('finish', function () { return cancel(); });
        next();
        var _a;
    };
}
exports.timeout = timeout;
