/// <reference types="express" />
import * as context from '@ctx/context';
import * as express from 'express';
declare global  {
    namespace Express {
        interface Request {
            ctx: context.Context;
        }
    }
}
/**
 * closeNotify returns a middleware that cancels the request's context when
 * the client closes the http connection.
 *
 * ```javascript
 * const app = express()
 *
 * app.use(expressCtx.closeNotify())
 * app.get('/', (req, res) => {
 *   req.ctx.Done().then(() => {
 *     if (ctx.Err() === context.Canceled) {
 *       console.log('user hung up')
 *     }
 *   })
 * })
 * ```
 */
export declare function closeNotify(): express.RequestHandler;
/**
 * readHeaders returns a middleware that converts headers on incoming requests
 * to values on the request's context object.
 *
 * ```javascript
 * const app = express()
 *
 * app.use(expressCtx.readHeaders(['x-user-id']))
 * app.get('/', (req, res) => {
 *   const xuid = req.ctx.Value('x-user-id')
 *   // Will be undefined if x-user-id was not passed, otherwise the value of
 *   //  x-user-id
 *   console.log(xuid)
 * })
 * ```
 *
 * @param headerNames - The names of the headers to map to context values
 */
export declare function readHeaders(headerNames: string[]): express.RequestHandler;
/**
 * timeout returns a middleware that attaches a context to the request that
 * will be cancelled after the duration specified in timeoutMilliseconds.
 *
 * ```javascript
 * const app = express()
 *
 * app.use(expressCtx.timeout(1000))
 * app.get('/', (req, res) => {
 *   req.ctx.Done().then(() => {
 *     req.end('timed out')
 *   })
 * })
 * ```
 *
 * @param timeoutMilliseconds The number of milliseconds before the context
 * will be cancelled
 */
export declare function timeout(timeoutMilliseconds: number): express.RequestHandler;
