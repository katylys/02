# @ctx/express
[![Build Status](https://travis-ci.org/node-context/express.svg?branch=master)](https://travis-ci.org/node-context/express)
[![Dependency Status](https://gemnasium.com/badges/github.com/node-context/express.svg)](https://gemnasium.com/github.com/node-context/express)

Middlewares to make using context's easier in Express applications.

See [the typedoc](https://node-context.github.io/express/modules/_index_.html)
for API documentation.

## Example

The `timeout` middleware attaches a context with a fixed timeout to every
incoming request. We can use this to implement a timeout for our users; if the
context times out, return an error message.

```
const express = require('express')
const expressCtx = require('@ctx/express')
const context = require('@ctx/context')

const app = express()
app.use(expressCtx.timeout(1000))
app.get('/', async (req, res) => {
  try {
    const data = await doSomething(req.ctx, req.body)
    res.json(data).end()
  } catch (err) {
    if (err === context.DeadlineExceeded) {
      res.status(500).end('timed out')
    } else {
      res.status(500).end('internal server error')
    }
  })
})
```

The `addHeader` reads headers from the request object and attaches them to the
context. This can ease some of the burden of passing values down through the
stack. For example,


```
const express = require('express')
const expressCtx = require('@ctx/express')
const context = require('@ctx/context')

const app = express()
app.use(expressCtx.addHeader(['x-user-id']))
app.get('/', async (req, res) => {
  const data = await doSomething(req.ctx, req.body)
  res.json(data).end()
})

function doSomething (ctx, body) {
  ...
  const username = getUsername(ctx)
  ...
}

function getUsername (ctx) {
  return usernames[ctx.Value('x-user-id')]
}
```

Other useful cases for this include passing a "request id" header to downstream
services for tracing and distributed logging.
