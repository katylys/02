"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Canceled is the error returned by Context.Err when the context is canceled.
 */
exports.Canceled = new Error('context canceled');
/**
 * DeadlineExceeded is the error returned by Context.Err when the context's
 * deadline passes.
 */
exports.DeadlineExceeded = new Error('deadline exceeded');
var NilContext = (function () {
    function NilContext() {
    }
    NilContext.prototype.Done = function () {
        return new Promise(function () {
            return {};
        });
    };
    NilContext.prototype.Deadline = function () {
        return undefined;
    };
    NilContext.prototype.Timeout = function () {
        return undefined;
    };
    NilContext.prototype.Err = function () {
        return undefined;
    };
    NilContext.prototype.Value = function (key) {
        return undefined;
    };
    return NilContext;
}());
/**
 * Background returns a empty Context. It is never canceled, has no values,
 * and has no deadline. It is typically used by the main function,
 * initialization, and tests, and as the top-level Context for incoming
 * requests.
 */
function Background() {
    return new NilContext();
}
exports.Background = Background;
/**
 * TODO returns a empty Context. Code should use context.TODO when it's unclear
 * which Context to use or it is not yet available (because the surrounding
 * function has not yet been extended to accept a Context parameter). TODO is
 * recognized by static analysis tools that determine whether Contexts are
 * propagated correctly in a program.
 */
function TODO() {
    return new NilContext();
}
exports.TODO = TODO;
var CancelContext = (function () {
    function CancelContext(parent) {
        var _this = this;
        this.parent = parent;
        this.err = this.parent.Err();
        this.done = new Promise(function (resolve) {
            _this.parent.Done().then(function () {
                if (!_this.err) {
                    _this.err = _this.parent.Err();
                }
                resolve();
            });
            _this.cancel = function () {
                if (!_this.err) {
                    _this.err = exports.Canceled;
                }
                resolve();
            };
        });
    }
    CancelContext.prototype.Done = function () {
        return this.done;
    };
    CancelContext.prototype.Deadline = function () {
        return this.parent.Deadline();
    };
    CancelContext.prototype.Timeout = function () {
        return this.parent.Timeout();
    };
    CancelContext.prototype.Err = function () {
        if (this.parent.Err()) {
            return this.parent.Err();
        }
        return this.err;
    };
    CancelContext.prototype.Value = function (key) {
        return this.parent.Value(key);
    };
    return CancelContext;
}());
/**
 * WithCancel returns a copy of parent with a new Done promise. The returned
 * context's Done promise is resolved when the returned cancel function is
 * called or when the parent context's Done promsie is resolved, whichever
 * happens first.
 *
 * Canceling this context releases resources associated with it, so code
 * should call cancel as soon as the operations running in this Context
 * complete.
 *
 * @param ctx The parent promise
 */
function WithCancel(ctx) {
    var child = new CancelContext(ctx);
    return [child, child.cancel];
}
exports.WithCancel = WithCancel;
var DeadlineContext = (function () {
    function DeadlineContext(parent, deadline) {
        var _this = this;
        this.cancel = new CancelContext(parent);
        this.deadline = deadline;
        setTimeout(function () {
            _this.cancel.cancel();
            _this.cancel.err = exports.DeadlineExceeded;
        }, deadline.getTime() - Date.now());
    }
    DeadlineContext.prototype.Done = function () {
        return this.cancel.Done();
    };
    DeadlineContext.prototype.Deadline = function () {
        var parent = this.cancel.Deadline();
        if (parent && parent.getTime() < this.deadline.getTime()) {
            return parent;
        }
        return this.deadline;
    };
    DeadlineContext.prototype.Timeout = function () {
        return this.Deadline().getTime() - Date.now();
    };
    DeadlineContext.prototype.Err = function () {
        return this.cancel.Err();
    };
    DeadlineContext.prototype.Value = function (key) {
        return this.cancel.Value(key);
    };
    return DeadlineContext;
}());
/**
 * WithTimeout returns WithDeadline(parent, Date.now() + timeout).
 *
 * Canceling this context releases resources associated with it, so code should
 * call cancel as soon as the operations running in this Context complete.
 *
 * @param ctx The parent context
 * @param timeoutMilliseconds The number of milliseconds before the deadline
 *                            will be exceeded
 */
function WithTimeout(ctx, timeoutMilliseconds) {
    var deadline = new Date(Date.now() + timeoutMilliseconds);
    return WithDeadline(ctx, deadline);
}
exports.WithTimeout = WithTimeout;
/**
 * WithDeadline returns a copy of the parent context with the deadline adjusted
 * to be no later than `deadline`. If the parent's deadline is already earlier
 * than `deadline`, `WithDeadline(parent, deadline)` is semantically equivalent
 * to parent. The returned context's Done promise is resolved when the deadline
 * expires, when the returned cancel function is called, or when the parent
 * context's Done promise is resolved, whichever happens first.
 *
 * Canceling this context releases resources associated with it, so code should
 * call cancel as soon as the operations running in this Context complete.
 *
 * @param ctx The parent context
 * @param deadline The date when the deadline will be exceeded
 */
function WithDeadline(ctx, deadline) {
    var child = new DeadlineContext(ctx, deadline);
    return [child, child.cancel.cancel];
}
exports.WithDeadline = WithDeadline;
var ValueContext = (function () {
    function ValueContext(parent, key, value) {
        this.cancel = new CancelContext(parent);
        this.key = key;
        this.value = value;
    }
    ValueContext.prototype.Done = function () {
        return this.cancel.Done();
    };
    ValueContext.prototype.Deadline = function () {
        return this.cancel.Deadline();
    };
    ValueContext.prototype.Timeout = function () {
        return this.cancel.Timeout();
    };
    ValueContext.prototype.Err = function () {
        return this.cancel.Err();
    };
    ValueContext.prototype.Value = function (key) {
        if (key === this.key) {
            return this.value;
        }
        return this.cancel.Value(key);
    };
    return ValueContext;
}());
/**
 * WithValue returns a copy of parent in which the value associated with key is
 * val.
 *
 * Use context Values only for request-scoped data that transits processes and
 * APIs, not for passing optional parameters to functions.
 *
 * @param ctx The parent context
 * @param key The key associated with val in the returned context
 * @param val The value associated with key in the returned context
 */
function WithValue(ctx, key, value) {
    var child = new ValueContext(ctx, key, value);
    return [child, child.cancel.cancel];
}
exports.WithValue = WithValue;
